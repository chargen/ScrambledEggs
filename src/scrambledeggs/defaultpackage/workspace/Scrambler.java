package scrambledeggs.defaultpackage.workspace;

/**
 * @author Alex Hendrix (amhendr2)
 * @author Vince English (english7)
 * @author Jeff Augustine (jaaugus2)
 * 
 * ====================================================================================
 *  Scrambler Class
 * ====================================================================================
 * 
 * Provides the message processing behind the Android User Interface, handles just about everything
 * to do with:
 * 
 * - Scrambling/Unscrambling
 * - Formatting
 * - Error Checking
 * - Transforming (between a single String and a String array)
 * - Removing Messages from Arrays
 * 
 * NOTE: Does NOT handle file storage, check SEFileUtilities for data storage implementation
 * 
 * All functions are static.
 * 
 */

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Scrambler {
	
	/**
	 * Method - scramble
	 * 
	 * Description - The scramble method takes input text and password and will create an
	 * encoded message that will only be reverted to its original state by the
	 * method unscramble and correct password.
	 * 
	 * The format of the string after being scrambled is as follows (ignore '[' and ']')
	 * sbe[SCRAMBLED MESSAGE]SBE
	 * 
	 * @param s - The String to be scrambled
	 * @param p - The password
	 * @return output - The scrambled String
	 */

	public static String scramble(String s, String p) {
		String output = "sbe"; // Adds a string to know if the text was encoded by the scramble method for decoding.
		
		if (p.equals(null) || p.equals("")) // Default password if no password is input.
			p = "ScRaMbLeD";
		
		char[] sArray = new char[s.length()]; // Text array to be modified.
		
		for (int i = 0; i < s.length(); i++) { // Create char array from text message input.
			sArray[i] = s.charAt(i);
		}
		
		char[] pArray = new char[p.length()]; // Password shift array
		
		for (int i = 0; i < p.length(); i++) {
			pArray[i] = p.charAt(i); // Create char shift array from password input.
		}
		
		for (int i = 0, j = 0; i < sArray.length; i++, j++) {
			if (j > pArray.length - 1)
				j = 0;
			
			// This turns all whitespace characters into normal spaces
			if(sArray[i] == '\n' || sArray[i] == '\t') sArray[i] = ' ';
			
			// Encode the array. If for any reason a character is out of bounds, ignore it
			if ((int)sArray[i] >= 32 && (int)sArray[i] <= 126){
				/* text[character] will be summed with password[character] to create
				 * an encoded character(char) between 32 (space) and 126 (~),
				 * mod 95 keeps characters between space and tilde.
				 */
				sArray[i] = (char) (32 + (((sArray[i] - 32 + pArray[j]) % 95) + 95) % 95);
			}
		}
		
		for (int i = 0; i < sArray.length; i++) { // Reconstruct the array to the output string.
			output += sArray[i];
		}

		output = output.concat("SBE"); // Append "SBE" to the end to act as a marker for the end of the message
		return output;
	}

	/**
	 * Method - unscramble
	 * 
	 * Description - The unscramble method takes scrambled text and password and will create the
	 * original message provided the password it right.
	 * 
	 * @param s - The String to be unscrambled
	 * @param p - The password to unscramble s
	 * @return output - The (hopefully) unscrambled message
	 */
	
	public static String unscramble(String s, String p) {
		String output = "";
		
		if (!isScrambled(s)){ // Check to see if the String was scrambled by our scramble method
			return s;
		}
		
		int end = s.indexOf("SBE"); // Define the end point to be right before SBE
		
		if (p.equals(null) || p.equals(""))// Default password.
			p = "ScRaMbLeD";
		char[] sArray = new char[end - 3]; // Text array to be modified
		for (int i = 0; i < sArray.length; i++) { // Create char array from text message input.
			sArray[i] = s.charAt(i + 3);
		}
		char[] pArray = new char[p.length()]; // Password shift array
		for (int i = 0; i < p.length(); i++) {
			pArray[i] = p.charAt(i); // Create char shift array from password input.
		}
		for (int i = 0, j = 0; i < sArray.length; i++, j++) {
			if (j > pArray.length - 1)
				j = 0;
			if ((int)sArray[i] >= 32 && (int)sArray[i] <= 126) {
				// Decode the array. If for any reason a character is out of bounds, ignore it.
				sArray[i] = (char) (32 + (((sArray[i] - 32 - pArray[j]) % 95) + 95) % 95);
			}
		}
		for (int i = 0; i < sArray.length; i++) {
			output += sArray[i]; // Generate the output array
		}
		return output;
	}

	/**
	 * Method - isScrambled
	 * 
	 * Description - isScrambled checks to see if the given String was generated by the scrambler method.
	 * It must pass two conditions:
	 * 1) It begins with "sbe"
	 * 2) It has "SBE" somewhere later in the String
	 * "sbe" and "SBE" define the bounds of of the message, so it's vital that both of
	 * these conditions are met.
	 * 
	 * @param s - The String to be checked
	 * @return A boolean representing if the string is indeed scrambled.
	 */
	
	public static boolean isScrambled(String s) {
		return s.indexOf("sbe") == 0 && s.indexOf("SBE") != -1;
	}
	
	/**
	 * Method - checkValidCharacters
	 * 
	 * Description - checkValidCharacters makes sure that all characters in the String are in between a space (32) and 
	 * a tilde (126). This function prevents the user from typing in crazy characters that the Scrambler has trouble handling.
	 * 
	 * @param s - The String to be checked
	 * @return A boolean representing if all the characters are valid
	 */
	
	public static boolean checkValidCharacters(String s){
		for(int i = 0; i < s.length(); i++){
			if((int)s.charAt(i) < 32 || (int)s.charAt(i) > 126)
				if(s.charAt(i) != '\n' && s.charAt(i) != '\t')
					return false;
		}
		return true;
	}
	
	/**
	 * Method - appendPassword
	 * 
	 * Description - appendPassword is called option if the user checks the "Include Password" check box within
	 * SendScreenActivity once the "Send" button is clicked. The password is simply appended to the message with "PW: "
	 * in front for readability.
	 * 
	 * @param message - The message to append the password to
	 * @param pass - The password to decode the message
	 * @return - The message appended with the password
	 */
	

	public static String appendPassword(String message, String pass) {
		message = message.concat("  PW: " + pass);
		return message;
	}

	/**
	 * Method - formatMessage
	 * 
	 * Description - formatMessage formats a single message as follows: (ignore '[' and ']')
	 * [MESSAGE][CONTACT]#&#&#[DATE]#%#%#
	 * 
	 * #&#&# Separates the CONTACT from the DATE
	 * #%#%# Separates two formatted messages
	 * 
	 * NOTE: The formatMessage does not put "sbe" and "SBE" at the ends of the scrambled message,
	 * however, "SBE" are the characters that separate the message and the contact number
	 * 
	 * This function is called when receiving a new message, so the Date generated will be the time
	 * that a message is received.
	 * 
	 * @param message - The scrambled message, formatting will be appended onto this message
	 * @param contact - The contact that will be appended to the message
	 * @return message - message is now formatted as shown above
	 */
	
	public static String formatMessage(String message, String contact) {
		
		// Creating new date based on the SimpleDateFormat
		DateFormat dateFormat = new SimpleDateFormat("MM/dd/yyyy HH:mm");
		Date date = new Date();

		// If this is a scrambled message, append the date, if not, append it anyway.
		// The error checking functions later will catch any non-formatted Strings and handle
		// any non-formatted Strings accordingly.
		if (extractMessage(message) != null)
			message = Scrambler.extractMessage(message);
		
		// Append the contact
		message += contact;
		
		// Append the date and appropriate formatting
		message = message + "#&#&#" + dateFormat.format(date) + "#%#%#";
		return message;
	}
	
	/**
	 * Method - prepareMessages
	 * 
	 * Description - prepareMessages breaks apart each formatted String (formatted by
	 * the formatMessage method) using the extract functions (see extractDate, extractContact,
	 * and extractMessage functions) and formats them nicely to display as follows:
	 * 
	 * 		Message Number: i
	 * 	From: [Contact Number] [Date]
	 * 	[Message]
	 * 
	 * Then PREPENDS this message to a String including all previously prepared Strings in the array.
	 * This method uses a StringBuilder since so many appends and prepends to Strings are being made, this
	 * will save a lot of time when dealing with large amounts of texts (versus a String)
	 * 
	 * 
	 * @param messages - An array of formatted messages
	 * @return formattedMessages.toString() - A single String containing nicely formatted and readable messages
	 */

	public static String prepareMessagesForDisplay(String[] messages) {
		StringBuilder formattedMessages = new StringBuilder();
		for (int i = 0; i < messages.length; i++) {
			
			//PREPEND each prepared message according the format shown above
			formattedMessages.insert(0, '\t' + "Message Number: " + (messages.length - i) + '\n'
							+ Scrambler.extractDate(messages[i]) + 
							"  From: " + Scrambler.extractContact(messages[i]) + '\n'
							+ Scrambler.extractMessage(messages[i]) + '\n'
							+ '\n');
		}
		
		return formattedMessages.toString();
	}
	
	/**
	 * Method - getMessagesArray
	 * 
	 * Description - Takes a single String of formatted (not prepared) messages and makes a String
	 * array of messages
	 * 
	 * NOTE: This is very often used when retrieving messages from a file
	 * Also, since this method is used to load in files, it also monitors how many messages are in the array,
	 * if there are over 25, the oldest one (index 0) is deleted.
	 * 
	 * @param messagesString - A single String of messages
	 * @return messages - A String array of messages
	 */
	

	public static String[] getMessagesArray(String messagesString) {
		
		//Split the messages according to the ending tag on each one
		String[] messages = messagesString.split("#%#%#");
		
		//The repair them...
		repairAfterSplit(messages);
		
		//And delete the ones that aren't formatted correctly
		messages = cleanUpMessages(messages);
		
		//Always keep the number of messages from going over 25 so the buffer doesn't overflow when reading messages
		if(messages.length > 25) removeSingleMessage(messages, 0);
		
		return messages;
	}
	
	/**
	 * Method - getMessagesString
	 * 
	 * Description - Obtains a single String of formatted (not prepared) messages from an array
	 * of messages
	 * 
	 * NOTE: This is very often used in preparing a set of messages to being stored to a file
	 * 
	 * @param messagesArray - A String array of messages to be transferred into a single String
	 * @return messages - A String of messages that was previously spread across messagesArray
	 */

	public static String getMessagesString(String[] messagesArray) {
		String messages = "";
		
		// Remove any corrupted messages... just to be sure
		cleanUpMessages(messagesArray);
		
		// Then write all of the individual messages into one String
		for (int i = 0; i < messagesArray.length; i++)
			messages += messagesArray[i];
		
		return messages;
	}

	/**
	 * Method - extractMessage
	 * 
	 * Description - Removes the scrambled message from a formatted message as
	 * shown below (ignore '[' and ']', the characters '{' and '}' represent what is being extracted):
	 * 
	 * NOTE: This method does not assume the String is formatted correctly, and will return null if it's not,
	 * this method is also used to check if a String formatted properly.
	 * 
	 * {sbe[MESSAGE]SBE}[CONTACT]#&#&#[DATE]#%#%#
	 * 
	 * @param s - The string to extract the scrambled message from
	 * @return The extracted message (or null if corrupted)
	 */

	public static String extractMessage(String s) {
		int start = s.indexOf("sbe");
		
		// If the String doesn't begin with "sbe", it's corrupted
		if (start != 0)
			return null;
		
		int end = s.indexOf("SBE");
		
		// If the String doesn't contain "SBE", it's corrupted
		if (end == -1)
			return null;
		
		end += 3; // Moving the end so SBE is included, this is needed to unscrambled the message

		return s.substring(start, end);
	}

	/**
	 * Method - extractContact
	 * 
	 * Description - Removes the contact from a formatted message as
	 * shown below (ignore '[' and ']', the characters '{' and '}' represent what is being extracted):
	 * 
	 * NOTE: This method does not assume the String is formatted correctly, and will return null if it's not,
	 * this method is also used to check if a String formatted properly.
	 * 
	 * sbe[MESSAGE]SBE{[CONTACT]}#&#&#[DATE]#%#%#
	 * 
	 * @param s - The string to extract the contact from
	 * @return The extracted contact (or null if corrupted)
	 */
	
	public static String extractContact(String s) {
		
		// The String is corrupted if it doesn't contain "SBE"
		int start = s.indexOf("SBE");
		if (start == -1)
			return null; 
		
		start += 3; // Removing SBE from string
		
		// #&#&# is the end tag for extracting the contact, if it isn't there
		// the String is corrupted
		int end = s.indexOf("#&#&#");
		if (end == -1)
			return null;
		// String is incompatible.. must've been #&#&# somewhere in the message
		if (start >= end)
			return null;
		return s.substring(start, end);
	}

	/**
	 * Method - extractDate
	 * 
	 * Description - Removes the date from a formatted message as
	 * shown below (ignore '[' and ']', the characters '{' and '}' represent what is being extracted):
	 * 
	 * NOTE: This method does not assume the String is formatted correctly, and will return null if it's not,
	 * this method is also used to check if a String formatted properly.
	 * 
	 * sbe[MESSAGE]SBE[CONTACT]#&#&#{[DATE]}#%#%#
	 * 
	 * @param s - The String to extract the date from
	 * @return The extracted date (or null if corrupted)
	 */
	
	public static String extractDate(String s) {
		
		// #&#&# is the start tag for extracting the contact, if it isn't there
		// the String is corrupted
		int start = s.indexOf("#&#&#");
		if (start == -1)
			return null; 
		
		start += 5; // Removing #&#&# from string
		
		// #%#%# is the end tag for extracting the contact, if it isn't there
		// the String is corrupted
		int end = s.indexOf("#%#%#");
		if (end == -1)
			return null;
		
		// String is incompatible... must've been #%#%# somewhere in the message
		if (start >= end)
			return null; 
		
		return s.substring(start, end);
	}

	/**
	 * Method - repairAfterSplit
	 * 
	 * Description - When a string of messages is being split into an array, the split function
	 * deletes the parameter (#%#%#) within the string when forming the array, this function puts the
	 * parameter back in, as it is necessary for them to be considered formatted correctly.
	 * 
	 * @param s - The array before repair
	 * 
	 */
	
	public static void repairAfterSplit(String[] s) {
		//Append the end tag, #%#%#, to every message
		for (int i = 0; i < s.length; i++) {
			s[i] += "#%#%#";
		}
	}

	/**
	 * Method - isFragmented
	 * 
	 * Description - The maximum allowed length of all messages (including formatting) combined is 5000 characters,
	 * when that maximum is reached, the last message might be fragmented, this function will detect that, and proper
	 * action will be taken.
	 * 
	 * @param s - The String to test
	 * @return A boolean denoting if the String is fragmented
	 */
	
	public static boolean isFragmented(String s) {
		return s.indexOf("#%#%#") == -1;
	}
	
	/**
	 * Method - isReadable
	 * 
	 * Description - The ultimate test of proper formatting, runs a certain String through all tests, must past 4 trials:
	 * 1) A message must be extracted
	 * 2) A contact must be extracted
	 * 3) A date must be extracted
	 * 4) The String can't be fragmented
	 * 
	 * The String must pass all four tests to be considered readable, and therefore, usable.
	 * 
	 * @param s - The String to be put through all the tests
	 * @return A boolean denoting if the String has passed all tests or not
	 */

	public static boolean isReadable(String s) {
		if (extractMessage(s) == null)
			return false;
		if (extractContact(s) == null)
			return false;
		if (extractDate(s) == null)
			return false;
		if (isFragmented(s) == true)
			return false;
		return true;
	}

	/**
	 * Method - cleanUpMessages
	 * 
	 * Description - Goes through an array of Strings (messages) and removes any that
	 * aren't readable (See isReadable for implementation of tests to pass to be 
	 * considered readable).
	 * 
	 * NOTE: Most often used after creating an array of messages from a single String
	 * of messages to make sure no garbage was created during the forming of the array
	 * 
	 * @param s - The String array (most likely messages) to be cleaned up
	 * @return s - An array with all readable messages
	 */

	public static String[] cleanUpMessages(String[] s) {
		
		// This needs to be declared so it can decrease every time a message is deleted
		int size = s.length;
		
		
		for (int i = 0; i < size; i++) {
			// If a message is unreadable.. remove it
			if (!Scrambler.isReadable(s[i])) {
				s = removeSingleMessage(s, i);
				size--;
			}
		}
		return s;
	}
	
	/** 
	 * Method - removeSingleMessage
	 * 
	 * Description - Removes a single String (message) from an array of messages
	 * 
	 * NOTE: This is very commonly used in partner with cleanUpMessages
	 * 
	 * @param s - The array with a String to remove
	 * @param index - The index of the String to remove
	 * @return newMessages - An array with the String removed
	 */
	
	public static String[] removeSingleMessage(String[] s, int index) {
		
		// Make a new array with one less spot than the one passed
		String[] newMessages = new String[s.length - 1];
		
		for (int i = 0; i < newMessages.length; i++) {
			//Have we hit the message we are suppose to delete? 
			//If not, copy the array normally, if so, skip over it
			newMessages[i] = (i < index) ? s[i] : s[i + 1];
		}
		return newMessages;
	}

	/**
	 * Method - removeMultipleMessages
	 * 
	 * Description - Removes a number of Strings (oldest messages) from a String array. Therefore, since new
	 * messages are appended to the file (so appended to the message array), it removes the FIRST strings in 
	 * the array, not the last. For example:
	 * 
	 * In an array of 4 Strings, if you were to remove 2 of them with the removeMultipleMessages method,
	 * you would remove indexes 0 and 1.
	 * 
	 * NOTE: This is used with the delete button in OptionsActivity when a user inputs the number
	 * of messages to delete.
	 * 
	 * @param s
	 * @param number
	 * @return
	 */
	
	public static String[] removeMultipleMessages(String[] s, int number) {
		// Create a new array thats the size of the array passed minus the number we're supposed to delete
		String[] newMessages = new String[s.length - number];
		
		// Read the correct position of the old aray into the new array
		for (int i = s.length - newMessages.length, j = 0; j < s.length - number; i++, j++) {
			newMessages[j] = s[i];
		}
		return newMessages;
	}
}
